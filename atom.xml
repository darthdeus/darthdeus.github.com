<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[darthdeus vs Ember.js]]></title>
  <link href="http://darthdeus.github.com/atom.xml" rel="self"/>
  <link href="http://darthdeus.github.com/"/>
  <updated>2013-01-27T12:38:31+01:00</updated>
  <id>http://darthdeus.github.com/</id>
  <author>
    <name><![CDATA[Jakub Arnold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Controller's Needs Explained]]></title>
    <link href="http://darthdeus.github.com/blog/2013/01/27/controllers-needs-explained/"/>
    <updated>2013-01-27T11:53:00+01:00</updated>
    <id>http://darthdeus.github.com/blog/2013/01/27/controllers-needs-explained</id>
    <content type="html"><![CDATA[<p>Since the v2 router came it became clear that using global singleton controllers like <code>App.userController = App.UserController.create()</code> is not the way to go. This prevents us from doing a simple binding like</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">App</span><span class="p">.</span><span class="nx">UserController</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Controller</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">accountsBinding</span><span class="o">:</span> <span class="s2">&quot;App.accountsController.content&quot;</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>There is no need or even possibility to manage the controller instances with the new router though. It will create the instance for us. One way we can use this is with <code>this.controllerFor</code>, which can be used inside of a route.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">App</span><span class="p">.</span><span class="nx">UserRoute</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Route</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">setupController</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">controller</span><span class="p">,</span> <span class="nx">model</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// some magic with `this.controllerFor(&quot;user&quot;)`</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>but since this method is only available on the route and not inside a controller, it wasn&#8217;t very pleasant to specify dependencies (or needs) between controllers. Which is exactly where needs come in and solve the issue</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">App</span><span class="p">.</span><span class="nx">UserController</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Controller</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">needs</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>this will give you the opportunity to call <code>controllers.foo</code> on the <code>App.UserController</code> instance and get back an instance of <code>App.FooController</code>. You could even (ab)use that in the templates like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="c">&lt;!-- inside `users` template --&gt;</span>
</span><span class='line'>{{controllers.foo}}
</span></code></pre></td></tr></table></div></figure>


<h2>Needs vs routing</h2>

<p>Needs become incredibly useful when you have nested routes, for example</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">App</span><span class="p">.</span><span class="nx">Router</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">resource</span><span class="p">(</span><span class="s2">&quot;post&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s2">&quot;/posts/:post_id&quot;</span> <span class="p">},</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">route</span><span class="p">(</span><span class="s2">&quot;edit&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s2">&quot;/edit&quot;</span> <span class="p">});</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case we will get <code>post</code>, <code>post.index</code> and <code>post.edit</code>. If you go to <code>/posts/1</code> you expect to get <code>post.index</code> template, which is true, but the context (or model, or content) is being set on the <code>PostController</code>, not on <code>PostIndexController</code>.</p>

<p>When you think about it it does make sense, because the <code>resource</code> is basically shared between <code>post.index</code> and <code>post.edit</code>, that&#8217;s why it is fetched and stored in their parent. Let&#8217;s go through this in detail:</p>

<ul>
<li>visit <code>/posts/1</code></li>
<li>router basically does <code>App.Post.find(1)</code> <strong>and assigns that to the content of <code>PostController</code></strong></li>
<li>template <code>post</code> is rendered</li>
<li>template <code>post.index</code> is rendered in <code>post</code>&#8217;s outlet</li>
</ul>


<p>and when you transition to <code>/posts/1/edit</code>, the only thing that changes is the leaf route, you still keep the same <code>App.Post</code> model, because it belongs to the parent <code>PostRoute</code>, not to the leaf <code>PostIndexRoute</code>. But this has a drawback. You&#8217;re not able to directly access the content from the <code>post.index</code> template, since it doesn&#8217;t belong to it&#8217;s controller. That&#8217;s where needs come in.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">App</span><span class="p">.</span><span class="nx">PostIndexController</span> <span class="o">=</span> <span class="nx">Ember</span><span class="p">.</span><span class="nx">Controller</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">needs</span><span class="o">:</span> <span class="p">[</span><span class="s2">&quot;post&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>and in the <code>post/index</code> template, you can access the content like this</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>{{controllers.post.content}}
</span></code></pre></td></tr></table></div></figure>


<p>By specifying the need Ember will make sure that it gives you the right <code>PostController</code> instance with it&#8217;s content set to the right value.</p>
]]></content>
  </entry>
  
</feed>
