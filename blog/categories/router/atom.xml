<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Router | darthdeus vs Ember.js]]></title>
  <link href="http://darthdeus.github.com/blog/categories/router/atom.xml" rel="self"/>
  <link href="http://darthdeus.github.com/"/>
  <updated>2013-02-20T00:36:58+01:00</updated>
  <id>http://darthdeus.github.com/</id>
  <author>
    <name><![CDATA[Jakub Arnold]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Router Request Lifecycle]]></title>
    <link href="http://darthdeus.github.com/blog/2013/02/08/router-request-lifecycle/"/>
    <updated>2013-02-08T16:59:00+01:00</updated>
    <id>http://darthdeus.github.com/blog/2013/02/08/router-request-lifecycle</id>
    <content type="html"><![CDATA[<p>Router is the core part of Ember. Every time we go to a new URL it means
the
route object is called with our params and stuff. These are the hooks
sorted in order in which they are called</p>

<ul>
<li>enter (private)</li>
<li>activate - executed when entering the route</li>
<li>deserialize (private)</li>
<li>model (formely deserialize) - takes the params and returns a model
which is set to the route's <code>currentModel</code></li>
<li>serialize - used to generate dynamic segments in the URL from a model</li>
<li>setupController - takes <code>currentModel</code> and sets it to the controller's
<code>content</code> by default</li>
<li>renderTemplate - takes current controller and what <code>model</code> returns and
renders the template with an appropriate name</li>
<li>deactivate - executed when exiting the route (called by exit
internally)</li>
<li>exit (private, requires call to <code>this._super</code>)</li>
</ul>


<p>Now let's take a look at them in more detail</p>

<h2><code>activate</code>/<code>deactivate</code></h2>

<p>These were formely known as <code>enter</code>/<code>exit</code>, which are now marked as
private. <code>activate</code> will be executed when user enters a route, be it
from a transition or from a URL directly, and <code>deactivate</code> is executed
when user transitions away from the route.</p>

<p>One of the most common use cases for me is doing a transaction rollback
in <code>deactivate</code>.</p>

<p>```javascript
App.PostsNewRoute = Ember.Route.extend({</p>

<p>  deactivate: function() {</p>

<pre><code>this.modelFor("postsNew").get("transaction").rollback();
</code></pre>

<p>  }</p>

<p>});
```</p>

<p>I find this mostly useful when having a <em>new record form</em> (or even when
editing a record), where you basically want to rollback any changes
which happened when the user exits the route. It doesn't matter if the
user submits the form first, because then the transaction will be
comitted and there will be nothing to rollback.</p>

<h2><code>model</code>/<code>serialize</code></h2>

<p>To allow Ember to work with dynamic segments in the URLs we need to
teach it how to serialize and deserialize our models. When we enter a
URL directly (or reload the page) <code>model</code> will be called with params
from the dynamic segments. Let's take a look at an example</p>

<p>```javascript
App.Router.map(function() {
  this.resource("post", { path: "/:post_id" });
});</p>

<p>App.PostRoute = Ember.Route.extend({</p>

<p>  model: function(params) {</p>

<pre><code>return App.Post.find(params.post_id);
</code></pre>

<p>  }</p>

<p>});
```</p>

<p>This is exactly what Ember will auto generate for us, along with a
serialize hook</p>

<p>```javascript
App.PostRoute = Ember.Route.extend({</p>

<p>  model: function(params) {</p>

<pre><code>return App.Post.find(params.post_id);
</code></pre>

<p>  },</p>

<p>  serialize: function(model) {</p>

<pre><code>return { post_id: model.id };
</code></pre>

<p>  }</p>

<p>});
```</p>

<p>it is important to note here that if we're transitioning from a
different route our <code>model</code> hook <em>will not be called</em>.</p>

<h2><code>setupController</code></h2>

<p>One step further after <code>model</code> comes <code>setupController</code>, which is meant
to set additional properties on the controller, or override it's
<code>content</code>.</p>

<p>But beware, there is no autogenerated <code>setupController</code> hook which sets to <code>content</code>,
this is done even before <code>setupController</code> is called <a href="https://github.com/emberjs/ember.js/blob/master/packages/ember-routing/lib/system/route.js#L79-82">in the <code>setup</code> hook</a> of the route. This is basically simulates the following:</p>

<p><code>javascript
setupController: function(controller, model) {
  controller.set("content", model);
}
</code></p>

<p>But it also means we can set additional properties on the controller
without needing to explicitly set the content</p>

<p><code>javascript
setupController: function(controller, model) {
  controller.set("foo", "bar");
}
</code></p>

<h2><code>renderTemplate</code></h2>

<p>The last one of the hooks is <code>renderTemplate</code> where you tell which
template you want to render in which outlet.</p>

<p>By default <code>renderTemplate</code> will call <code>this.render</code> as follows</p>

<p>```javascript
App.PostRoute = App.Route.extend({</p>

<p>  renderTemplate: function() {</p>

<pre><code>this.render("post", {
  into: "application",
  outlet: "main",
  controller: "post"
});
</code></pre>

<p>  }</p>

<p>});
```</p>

<p>In this case <code>render</code> will render the <code>post</code> template into the
<code>application</code> template's <code>main</code> outlet with the <code>PostController</code>.</p>

<p>This is the place where you can chose to render into other outlets. For
example let's say that your <code>application</code> template has a sidebar outlet
<code></code>.</p>

<p>```javascript
App.PostRoute = App.Route.extend({</p>

<p>  renderTemplate: function() {</p>

<pre><code>// render with the defaults
this.render();

// and once more for the sidebar outlet
this.render("similarPosts", {
  into: "application",
  outlet: "sidebar"
});
</code></pre>

<p>  }</p>

<p>});
```</p>

<h2>Important notes about <code>controllerFor</code> and <code>modelFor</code></h2>

<p>While calling <code>controllerFor("posts")</code> returns an instance of
<code>PostsController</code>, calling <code>modelFor("posts")</code> <strong>doesn't return
<code>content</code>
of the <code>PostController</code></strong>. Instead it looks up the <code>PostsRoute</code> and
returns it's <code>currentModel</code> which is set when we return a value from the
<code>model</code> hook.</p>

<p>Let's see an example</p>

<p>```javascript
App.PostsRoute = Ember.Route.extend({</p>

<p>  setupController: function(controller) {</p>

<pre><code>controller.set("content", App.Post.find());
</code></pre>

<p>  }</p>

<p>});
```</p>

<p>This will cause issues if we decide to use <code>modelFor</code> later on.
<code>PostsRoute</code> will not have anything in <code>currentModel</code> and <code>modelFor</code>
will return undefined, which might look weird as the controller has a
content properly set.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ember.js Router and Template Naming Convention]]></title>
    <link href="http://darthdeus.github.com/blog/2013/02/01/ember-dot-js-router-and-template-naming-convention/"/>
    <updated>2013-02-01T19:43:00+01:00</updated>
    <id>http://darthdeus.github.com/blog/2013/02/01/ember-dot-js-router-and-template-naming-convention</id>
    <content type="html"><![CDATA[<p>Ever since the change to <code>resource</code> and <code>route</code> a lot of people are
confused about the meaning of the two and how they affect naming. Here's
the difference:</p>

<ul>
<li><code>resource</code> - a thing</li>
<li><code>route</code> - something to do with the thing</li>
</ul>


<p>Let's say we have a model <code>App.Post</code> and we want to show a list of posts
and a new post form. There are many ways you can go about this, so let's
start with the simplest.</p>

<p><code>javascript
App.Router.map(function() {
  this.resource("posts", { path: "/" });
  this.route("new", { path: "/new" });
});
</code></p>

<p>This would result in the following template structure</p>

<p>```html</p>

<script type="text/x-handlebars" data-template-name="posts">
  ... list the posts
</script>




<script type="text/x-handlebars" data-template-name="new">
  ... new post template
</script>


<p>```</p>

<p>With the following naming</p>

<p><code>javascript
PostsRoute
PostsController
PostsView
NewRoute
NewController
NewView
</code></p>

<p><a href="http://jsbin.com/ogorab/33/edit">Here's a JSBin</a></p>

<p>This is almost never useful, since you might have many <code>/new</code> actions
and you'd need to scope them to the resource, which would be done as
follows</p>

<p>```javascript
App.Router.map(function() {
  this.resource("posts", { path: "/" }, function() {</p>

<pre><code>this.route("new", { path: "/new" });
</code></pre>

<p>  });
});
```</p>

<p>Here things get a little more complicated, since we're nesting something
inside the resource. This means that we'll end up with three templates
instead of two</p>

<p>```html</p>

<script type="text/x-handlebars" data-template-name="posts">
  <h1>This is the outlet</h1>

  
</script>




<script type="text/x-handlebars" data-template-name="posts/index">
  ... list the posts
</script>




<script type="text/x-handlebars" data-template-name="posts/new">
  ... new post template
</script>


<p>```</p>

<p>With the following naming</p>

<p>```javascript
PostsRoute
PostsController
PostsView</p>

<p>PostsIndexRoute
PostsIndexController
PostsIndexView</p>

<p>PostsNewRoute
PostsNewController
PostsNewView
```</p>

<p><a href="http://jsbin.com/ogorab/34/edit">Here's a JSBin</a></p>

<p>This means whenever you create a resource it will create a brand new
namespace. That namespace will have an <code></code> which is named after the
resource and all of the child routes will be inserted into it.</p>

<p>There are many reasons behind it, but let's try another example which
will make it more obvious. We will add a <code>/:post_id</code> and
<code>/:post_id/edit</code> routes.</p>

<p>```javascript
App.Router.map(function() {
  this.resource("posts", { path: "/" }, function() {</p>

<pre><code>this.resource("post", { path: "/:post_id" }, function() {
  this.route("edit", { path: "/edit" });
});

this.route("new", { path: "/new" });
</code></pre>

<p>  });
});
```</p>

<p>Additional to the routes in the previous example, this will give us</p>

<p><code>``javascript
// IMPORTANT - it's not PostsPostRoute, because</code>resource`
// always creates a new namespace
PostRoute
PostController
PostView</p>

<p>PostIndexRoute
PostIndexController
PostIndexView</p>

<p>PostEditRoute
PostEditController
PostEditView
```</p>

<p>Templates are named accordingly <code>post</code>, <code>post.index</code> and <code>post.edit</code>,
<strong>there is nothing like <code>posts.post.index</code> or <code>posts.post</code> or
<code>posts.post.edit</code></strong>.</p>

<p><a href="http://jsbin.com/ogorab/35/edit">Here's a JSBin</a></p>

<p>But the problem is when we try to access the <code>App.Post</code> model from the
<code>post/index</code> or <code>post/edit</code> template. It is only available in the <code>post</code>
template with the outlet. Now why is that?</p>

<p>Since we are defining a <code>resource</code> it is expected that the child routes
will be related to that <code>resource</code>, that's why they don't need to load
it separately. They can access it from the parent <code>PostController</code> via
<code>needs</code> (<a href="http://darthdeus.github.com/blog/2013/01/27/controllers-needs-explained/">more about that can be found in this article</a></p>

<p><a href="http://jsbin.com/ogorab/44/edit">Here's a JSBin</a></p>

<p>This is the general pattern you would be using if you want to nest
everything. But what if you don't want to render <code>post</code> into the
<code>posts</code> outlet? Well nothing prevents you from defining the routes as
this.</p>

<p>```javascript
App.Router.map(function() {
  this.resource("posts", { path: "/" }, function() {</p>

<pre><code>this.route("new", { path: "/new" });
</code></pre>

<p>  });</p>

<p>  this.resource("post", { path: "/:post_id" }, function() {</p>

<pre><code>this.route("edit", { path: "/edit" });
</code></pre>

<p>  });
});
```</p>

<p>What is the difference? The naming remains exactly the same as in the
previous example, even templates are named the same. But the <code>post</code>
template will be inserted into the <code>application</code> layout, not inside the
<code>posts</code> layout. This is the case when you want the detail <code>post</code> page to
replace the whole layout, instead of just showing it together with the
<code>posts</code> list.</p>

<p>I hope the examples will help you understanding how the v2 routes work,
since this is a completely essential part of Ember.js.</p>

<p>If you have any questions, leave them in the comments or tweet me
<a href="http://twitter.com/darthdeus">@darthdeus</a>.</p>
]]></content>
  </entry>
  
</feed>
